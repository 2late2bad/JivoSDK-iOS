//
//  ChatManager.swift
//  JivoSDK
//
//  Created by macbook on 15.09.2020.
//  Copyright © 2020 jivosite.mobile. All rights reserved.
//

import Foundation
import JMCodingKit
import JMShared

class ChatManager: BaseManager<ChatProto>, IChatManager {
    // MARK: - Enums
    
    enum AgentDataReceivingMode {
        case channel
        case chat
    }
    
    // MARK: - Constants
    
    let FILE_SIZE_LIMIT = 10
    
    // MARK: - Public properties
    
<<<<<<< HEAD
    var serverPrefix: String? {
        didSet { serverPrefixUpdated() }
    }
=======
    var serverPrefix: String?
>>>>>>> 1ac979d94af1d6af0d23830390b3da2583461301
    
    var chat: ModelRef<Chat>?
    
    // MARK: - Private properties
    
    private var _isFirstSessionInitialization = true
    private var isFirstSessionInitialization: Bool {
        get {
            defer { _isFirstSessionInitialization = false }
            return _isFirstSessionInitialization
        }
        set {
            _isFirstSessionInitialization = newValue
        }
    }
    private var isAllChatHistoryLoaded = false
    private var userDataReceivingMode: AgentDataReceivingMode = .channel
    
    private var agents: [ModelRef<Agent>] = []
    private var chatHistory: [ModelRef<Message>] = []
    
    private var subStorage: IChatSubStorage
    private var subSender: IChatSubSender
    private var subUploader: IChatSubUploader
    
    private let typingCacheService: ITypingCacheService
    private let workflowsService: IWorkflowsService
    
    private let keychainDriver: IKeychainDriver
    
    private let eventSignal = BroadcastTool<ChatEvent>()
    
    // MARK: - Init
    
    init(
        thread: DispatchThread,
        userContext: IUserContext,
        proto: ChatProto,
        chatSubStorage: IChatSubStorage,
        chatSubSender: IChatSubSender,
        chatSubUploader: IChatSubUploader,
        systemMessagingService: ISystemMessagingService,
        networkEventDispatcher: INetworkEventDispatcher,
        typingCacheService: ITypingCacheService,
        workflowsService: IWorkflowsService,
        keychainDriver: IKeychainDriver
    ) {
        self.subStorage = chatSubStorage
        self.subSender = chatSubSender
        self.subUploader = chatSubUploader

        self.typingCacheService = typingCacheService
        self.workflowsService = workflowsService
        
        self.keychainDriver = keychainDriver
        
        super.init(
            thread: thread,
            userContext: userContext,
            proto: proto,
            networkEventDispatcher: networkEventDispatcher)
    }
    
    // MARK: - Public methods
    
    func sendMessage(_ text: String?, withAttachments attachments: [ChatPhotoPickerObject]? = nil) {
        guard let chat = obtainChat()?.resolved else {
            print("\nJivoSDK log: Can not send message because chat was not obtained – something went wrong."); return
        }
        
        let image: UIImage
        let fileUrl: URL, imageUrl: URL?
        if let attachment = attachments?.first {
            if case let ChatPhotoPickerObjectPayload.file(meta) = attachment.payload {
                fileUrl = meta.url
            } else if case let ChatPhotoPickerObjectPayload.image(meta) = attachment.payload {
                imageUrl = meta.url
                image = meta.image
            }
        }
        
        if let text = text, text.trimmed().count > 0 {
            guard let message = enqueueOutgoing(text: text.trimmed(), chatID: chat.ID) else {
                print("\nJivoSDK log: Can not add message text to the sending queue. Message text won't be send.\n"); return
            }
            notifyObservers(event: .messageSending(subStorage.reference(to: message)), onQueue: .main)
        } else {
            print("\nJivoSDK log: Can not send message text because it equals 'nil' or empty string.\n")
        }
        
        if let attachments = attachments, not(attachments.isEmpty) {
            let workflows = attachments.map {
                AttachmentSendingWorkflow(chatManager: self, chat: chat, object: $0)
            }
            workflows.forEach { _ = workflowsService.scheduleWorkflow($0) }
        } else {
            print("\nJivoSDK log: Attachment array is empty.\n")
        }
    }
    
    func resendMessage(uuid: String) {
        guard let message = subStorage.messageWithUUID(uuid) else {
            print("\nJivoSDK log: Can not find a message with UUID = \(uuid). Message won't be resend.\n"); return
        }
        subStorage.resendMessage(message)
        
        notifyObservers(event: .messageSending(subStorage.reference(to: message)), onQueue: .main)
    }
    
    func sendUpload(chat: Chat, mode: CommanderUploadMode, result: UploadingResult) {
        switch result {
        case .success(let meta):
            let message = subStorage.enqueueOutgoingMessage(
                localID: UUID().uuidString.lowercased(),
                clientID: userContext.crc32EncryptedClientId,
                chatID: chat.ID,
                type: .message,
                content: convert(mode) { value in
                    switch value {
                    case .image:
                        return MessageContent.photo(
                            mime: meta.mime,
                            name: meta.name,
                            link: meta.link,
                            dataSize: meta.dataSize,
                            width: Int(meta.pixelSize.width),
                            height: Int(meta.pixelSize.height))
                    case .file:
                        return MessageContent.file(
                            mime: meta.mime,
                            name: meta.name,
                            link: meta.link,
                            size: meta.dataSize)
                    }
                })
            
            if let message = message {
                notifyObservers(event: .messageMediaUploaded(subStorage.reference(to: message)), onQueue: .main)
            }
            
        case .cannotExtractData, .exportingFailed:
            notifyObservers(event: .mediaUploadFailure(withError: .extractionFailed), onQueue: .main)
            
        case .sizeLimitExceeded:
            notifyObservers(event: .mediaUploadFailure(withError: .fileSizeExceeded(limit: FILE_SIZE_LIMIT)), onQueue: .main)
            
        case .unknownError:
            notifyObservers(event: .mediaUploadFailure(withError: .unknownError), onQueue: .main)
        }
    }
    
    func restoreChat() {
        if let chat = obtainChat()?.resolved {
            chat._agents.forEach {
                if not(self.agents.map(\.resolved).contains($0)) {
                    self.agents.append(subStorage.reference(to: $0))
                }
            }
            
            chatHistory = subStorage.messages(forChatId: chat.ID).map {
                return subStorage.reference(to: $0)
            }
            
            notifyObservers(event: .historyLoaded(history: chatHistory), onQueue: .main)
            notifyObservers(event: .chatObtained(subStorage.reference(to: chat)), onQueue: .main)
            notifyObservers(event: .agentsObtained(agents: agents), onQueue: .main)
        }
    }
    
    func message(byUuid uuid: String) -> Message? {
        return subStorage.messageWithUUID(uuid)
    }
    
    func requestMessageHistory(fromMessageWithId lastMessageId: Int? = nil) {
        if not(isAllChatHistoryLoaded) {
            proto.requestMessageHistory(fromMessageWithId: lastMessageId)
        }
    }
    
    func addUploading(subject: UploadingSubject, purpose: UploadingPurpose, completion: @escaping (UploadingResult) -> Void) {
        subUploader.addUploading(subject: subject, purpose: purpose, completion: completion)
    }
    
    func subscribe(handler: @escaping (ChatEvent) -> ()) {
        eventSignal.attachObserver(handler)
        
        notifyObservers(event: .historyLoaded(history: chatHistory), onQueue: .main)
        notifyObservers(event: .agentsObtained(agents: agents), onQueue: .main)
    }
    
    // MARK: - Private methods
    
    // MARK: BaseManager methods
    
    override func run() {
        subStorage.eventSignal.attachObserver { [weak self] in
            self?.handleSubStorageEvent($0)
        }
        subUploader.subscribeOn { [weak self] in
            self?.handleSubUploaderEvent(mediaUploadChanges: $0)
        }
        
        subSender.markSentMessagesAsFailed()
        restoreChat()
    }
    
    private func handleSubUploaderEvent(mediaUploadChanges: [MediaUploadChange]) {
        updateHistoryItems(mediaUploadChanges: mediaUploadChanges, animated: true)
    }
    
    private func updateHistoryItems(mediaUploadChanges: [MediaUploadChange], animated: Bool) {
        notifyObservers(event: .attachmentStartedToUpload(mediaUploadChanges), onQueue: .main)
    }
    
    override func handleProtoEvent(subject: IProtoEventSubject, context: ProtoEventContext?) {
        switch subject as? ChatProtoEventSubject {
        case .fileCredentials(let payload):
            handleFileCredentials(payload, context: context)
            
        default: break
        }
        
        switch subject as? SessionProtoEventSubject {
        case .socketOpen:
            handleSocketOpened()
            
        case let .socketClose(kind, error):
            handleSocketClosed(kind: kind, error: error)
            
        default: break
        }
    }
    
    override func handleProtoEvent(transaction: DataTransaction<ContextualProtoEventBundle>) {
        switch transaction.type {
        case .session(.me):
            let meTransaction = transaction.convert { $0.payload.subject as? MeTransactionSubject }
            handleMeTransaction(meTransaction)
        
        case .chat(.user):
            let userTransaction = transaction.convert { $0.payload.subject as? UserTransactionSubject }
            handleUserTransaction(userTransaction)
            
        case .chat(.message):
            let messageTransaction = transaction.convert { $0.payload.subject as? MessageTransactionSubject }
            handleMessageTransaction(messageTransaction)
        
        default: break
        }
    }
    
    // MARK: Proto event handling methods
    
    private func handleMeTransaction(_ transaction: DataTransaction<MeTransactionSubject>) {
        transaction.flatten.forEach { subject in
            guard case let MeTransactionSubject.meHistory(data) = subject else { return }
            guard let lastMessageId = data else {
                isAllChatHistoryLoaded = true
                return
            }
            #warning("TODO: Anton Karpushko, 23.02.2021 - Add code block if guard condition was passed.")
        }
    }
    
    private func handleMessageTransaction(_ transaction: DataTransaction<MessageTransactionSubject>) {
        guard let chat = obtainChat()?.resolved else { return }
        
        let messages = transaction.items.compactMap { item -> Message? in
            let message: Message? = {
                switch item.key {
                case let id as String:
                    return subStorage.upsertMessage(byPrivateId: id, inChatWithId: chat.ID, with: item.value)
                    
                case let id as Int:
                    return subStorage.upsertMessage(havingId: id, inChatWithId: chat.ID, with: item.value)
                    
                default: return nil
                }
            }()
            
            return message
        }
        
        let messageRefs = messages
            .compactMap { $0 }
            .sorted {
                if $0.date == $1.date {
                    return $0.ID < $1.ID
                } else {
                    return $0.date < $1.date
                }
            }
            .map { self.subStorage.reference(to: $0) }
        
        thread.async { [unowned self] in
            notifyObservers(event: .messagesReceived(messageRefs), onQueue: .main)
        }
    }
    
    private func handleUserTransaction(_ transaction: DataTransaction<UserTransactionSubject>) {
        let agents = transaction.items.compactMap { item -> Agent? in
            if let id = item.key.flatMap(String.init).flatMap(Int.init) {
                let agent = subStorage.upsertAgent(havingId: id, with: item.value)
                let state = agent?.state
                return agent
            } else {
                item.value.forEach {
                    switch $0 {
                    case .switchingDataReceivingMode:
                        self.userDataReceivingMode = .chat
                        updateAgents([], replacing: true, insideTransaction: false)
                    default: break
                    }
                }
                return nil
            }
        }
        
        thread.async { [unowned self] in
            if self.userDataReceivingMode == .chat {
                updateAgents(agents.filter { $0.state == .active }, replacing: false, insideTransaction: true)
            }
        }
    }
    
    private func handleSocketOpened() {
        chat = nil
        
        userDataReceivingMode = .channel
        
        notifyObservers(event: .historyErased, onQueue: .main)
        notifyObservers(event: .sessionInitialized(isFirst: isFirstSessionInitialization), onQueue: .main)
        
        requestMessageHistory()
    }
    
    private func handleSocketClosed(kind: APIConnectionCloseCode, error: Error?) {
        userDataReceivingMode = .channel
    }
    
    private func handleFileCredentials(_ meta: ProtoEventSubjectPayload.FileCredentials, context: ProtoEventContext!) {
        guard let object = context.object as? CommonFileContext else { return }
        
        switch meta.status {
        case .success:
            guard let config = meta.body.config else { return }
            
            let file = object.file
            let callback = object.callback
            
            proto
                .contextual(object: nil)
                .performUploadRequest(
                    file: file,
                    config: config,
                    callback: callback)
            
        default:
            object.callback(.cannotPrepare)
            notifyObservers(event: .mediaUploadFailure(withError: .extractionFailed), onQueue: .main)
        }
    }
    
    private func handleSessionStartedEvent() {
        chat = nil
        
        notifyObservers(event: .historyErased, onQueue: .main)
        notifyObservers(event: .sessionInitialized(isFirst: isFirstSessionInitialization), onQueue: .main)
    }
    
    // MARK: SubStorage event handling methods
    
    private func handleSubStorageEvent(_ event: ChatSubStorageEvent) {
        switch event {
        case .messageSendingFailure(let message):
            notifyObservers(event: .messageSendingFailure(subStorage.reference(to: message)), onQueue: .main)
            
        case .messageResending(let message):
            notifyObservers(event: .messageResending(subStorage.reference(to: message)), onQueue: .main)
        }
    }
    
    // MARK: Other private methods
    
    private func notifyObservers(event: ChatEvent, onQueue queue: DispatchQueue) {
        eventSignal.broadcast(event, async: queue)
    }
    
    private func serverPrefixUpdated() {
        proto.serverPrefix = serverPrefix
        subStorage.serverPrefix = serverPrefix
    }

    private func obtainChat() -> ModelRef<Chat>? {
        let clientToken = userContext.token
            ?? keychainDriver.retrieveAccessor(forToken: .token).string
            ?? {
                let token = UUID().uuidString
                userContext.token = token
                return token
            }()
        let encryptedToken = CRC32.encrypt(clientToken)
        let crc32EncryptedClientToken = encryptedToken == 0 ? -1 : encryptedToken
        
        print("\nJivoSDK log: Obtaining chat by CRC32 encrypted client publicId.\nThe client CRC32 encrypted publicId is: \(crc32EncryptedClientToken)\n")
        
        if let chat = self.chat {
            return chat
        }
        
        if let chat = subStorage.chatWithID(crc32EncryptedClientToken) {
            let chatReference = subStorage.reference(to: chat)
            self.chat = chatReference
            return chatReference
        }
        
        let chat = subStorage.createChat(
            withChatID: crc32EncryptedClientToken,
            andAgentId: subStorage.agents().first?.ID
        )
        let chatReference = chat.flatMap(subStorage.reference)
        self.chat = chatReference
        
        return chatReference
    }
    
    private func updateAgents(_ agents: [Agent], replacing: Bool, insideTransaction: Bool) {
        if replacing {
            self.agents = agents.map { subStorage.reference(to: $0) }
        } else {
            agents.forEach {
                if not(self.agents.map(\.resolved).contains($0)) {
                    self.agents.append(subStorage.reference(to: $0))
                }
            }
        }

        updateChatAgents(agents, exclusive: replacing, insideTransaction: insideTransaction)
        notifyObservers(event: .agentsObtained(agents: self.agents), onQueue: .main)
    }
    
    @discardableResult private func updateChatAgents(_ agents: [Agent], exclusive: Bool, insideTransaction: Bool) -> Chat? {
        guard let chat = obtainChat()?.resolved else {
            print("\nJivoSDK log: Can not obtain chat – something went wrong.\n");
            return nil
        }
        
        let chatChange = SdkChatAgentsUpdateChange(id: chat.ID, agents: agents, exclusive: exclusive)
        guard let updatedChat = subStorage.storeChat(change: chatChange, insideTransaction: insideTransaction) else {
            print("\nJivoSDK log: Chat was not stored – something went wrong.\n");
            return nil
        }
        
        return updatedChat
    }
    
    private func enqueueOutgoing(text: String, chatID: Int) -> Message? {
        return subStorage.enqueueOutgoingMessage(
            localID: UUID().uuidString.lowercased(),
            clientID: userContext.crc32EncryptedClientId,
            chatID: chatID,
            type: .message,
            content: .text(message: text))
    }
    
    override func reset() {
        isFirstSessionInitialization = true
        isAllChatHistoryLoaded = false
        userDataReceivingMode = .channel
        chatHistory = []
        chat = nil
        agents = []
        typingCacheService.resetInput(context: TypingContext(kind: .chat, ID: chat?.resolved?.ID ?? 0))
        subStorage.deleteAllMessages()
    }
}

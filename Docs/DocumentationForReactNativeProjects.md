# **Jivo Mobile SDK для iOS (beta)**
## Документация для React Native проектов

В этом документе содержатся версии разделов основного документа, адаптированные под интеграцию Jivo SDK в React Native проекты. Остальные разделы, не имеющие адаптации здесь, сохраняют свою актуальность и для React Native проектов.

## Установка

### CocoaPods

#### Требования

Для установки Jivo SDK в свой проект Xcode вам потребуется:
- Xcode 12.0 или новее;
- CocoaPods 1.10.0 или новее (проверить версию CocoaPods можно, выполнив следующую команду в терминале: `$ pod --version`); 
- настроить deployment target в проекте на iOS версии 11.0 или более новую.
 
> Также вам необходим проект Xcode, в который интегрирован UI приложения на React Native и для которого посредством CocoaPods установлены модули React. Обычно такой проект Xcode уже сгенерирован и находится в директории ios/. Если такой проект отсутствует, вы можете создать его, опираясь на [эту документацию](https://reactnative.dev/docs/integration-with-existing-apps).

#### Шаги установки
1. Установите плагин `cocoapods-user-defined-build-types` для CocoaPods.

   Для этого:
     - выполните в терминале следующую команду:

   ```bash
   $ gem install cocoapods-user-defined-build-types
   ```

     - откройте Xcode проект вашего приложения на React Native, расположенный в: `ios/YourAwesomeApp.xcworkspace`
     - Укажите и активируйте плагин в Podfile вашего Xcode проекта:

   ```ruby
   plugin 'cocoapods-user-defined-build-types' # укажите плагин
   enable_user_defined_build_types! # активируйте его

   target 'YourAwesomeApp' do  
     ...
   end
   ```

   > Плагин cocoapods-user-defined-build-types необходим по следующей причине. CocoaPods из коробки не позволяет настроить тип сборки (статическая или динамическая библиотека/фреймворк) отдельно для каждой зависимости, указанной в Podfile. Вместо этого можно лишь указать тип сборки сразу для всех зависимостей с помощью директивы use_frameworks!. В нашем случае в Podfile обязательно должны быть перечислены зависимости React Native (например, React), некоторые из которых являются статическими фреймворками. Также нам нужно указать зависимость JivoSDK, которая является динамическим фреймворком.

   > Так как в нашем Podfile должны быть указаны одновременно и статические, и динамические зависимости, мы не можем использовать директиву use_frameworks! и нам нужен способ настраивать тип сборки отдельно для каждой зависимости. Этот способ нам предоставляет плагин cocoapods-user-defined-build-types.

2. Укажите JivoSDK как зависимость в вашем Podfile, а также укажите для фреймворка тип сборки – dynamic_framework:

```ruby
target 'YourAwesomeApp' do
  pod 'JivoSDK', ‘~> 1.4’, :build_type => :dynamic_framework
  ...
end
```

3. Укажите в Podfile своего проекта следующие источники для pod'ов: 

```ruby
source 'https://github.com/CocoaPods/Specs.git' 
source 'https://github.com/JivoChat/JMSpecsRepo.git' 
```

4. Добавьте post-install блок в свой Podfile и пропишите в блоке версию iOS, указанную как основной deployment target:

```ruby
post_install do |installer| 
  installer.pods_project.targets.each do |target| 
    target.build_configurations.each do |config| 
      config.build_settings['BUILD_LIBRARY_FOR_DISTRIBUTION'] = 'YES'
      if target.name == 'libPhoneNumber-iOS' || target.name == 'BABFrameObservingInputAccessoryView' || target.name == 'SDWebImage'
        config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = [Версия iOS, указанная как основной deployment target]
      end
    end 
  end 
end
```

Посмотреть, какая версия iOS указана в качестве основного deployment target, можно в настройках основного таргета:

> Блок post-install добавляет поддержку module stability для всех pod'ов в вашем проекте. Это необходимо для того, чтобы один и тот же пакет JivoSDK.xcframework можно было использовать, не пересобирая на всех версиях Xcode выше 12.0 (версия, на которой JivoSDK.xcframework был собран). Корректная работа JivoSDK возможна только в том случае, если все его зависимости также будут поддерживать module stability. 

5. Находясь в директории `ios/` выполните в терминале команду:

```bash
$ pod install
```

6. Добавьте в проект Xcode файлы `JivoSDKModule.h` и `JivoSDKModule.m`, которые находятся в репозитории JivoSDK по пути `ReactNativeModule/Native`, как показано на скриншотах:

   `Не забудьте отметить чекбокс “Copy items if needed”!`

7. Добавьте в свой React Native проект файл `JivoSDKModule.js`, рпсполагающийся в репозитории JivoSDK по пути `ReactNativeModule/JivoSDKModule.js`.

## Использование

Jivo SDK JavaScript API содержит набор методов аналогичный по функциональности тому набору методов и свойств, что представлен в Jivo SDK Swift/Objective-C API. Отличие состоит лишь в их именах и способе получения к ним доступа:

```
JivoSDK.[вызываемый метод];
```

Выполнение всех операций внутри вызываемых методов происходит асинхронно. Для методов, предполагающих возвращение результата выполнения, используется передача функции обратного вызова в качестве параметра.

Методы принимают параметры строго определённого типа. Если тип переданных в метод данных не совпадает с ожидаемым, в консоли для отладки React Native приложения будет появляться соответствующее предупреждение.

Для того, чтобы получить доступ к модулю JivoSDK в JavaScript, вам необходимо импортировать этот модуль:

```js
import JivoSDK from '[путь к директории, в которой находится JivoSDKModule.js]/JivoSDKModule';
```

Пример кода для отображения UI чата SDK на экране:

```js
import JivoSDK from './JivoSDKModule';

const JivoSDKButton = () => {
  const myImage = require('./someImage.png');
  const resolveAssetSource = require('react-native/Libraries/Image/resolveAssetSource');
  const resolvedImage = resolveAssetSource(myImage);

  const onPress = () => {
    JivoSDK.startUpSession("ABCD12345", "some_token");
    JivoSDK.presentChattingUIWithConfig({
      "localeIdentifier": "ru_RU",
      "icon": resolvedImage,
      "titlePlaceholder": "Some title placeholder",
      "subtitleCaption": "Some subtitle caption",
      "inputPlaceholder": "Some input placeholder",
      "titleColor": "#AA33FF",
      "subtitleColor": "#CC2211",
    });
  };

  return (
    <Button
      title="Present Jivo SDK screen"
      color="#841584"
      onPress={onPress}
    />
  );
}

const App: () => Node = () => {
  const backgroundStyle = {
    backgroundColor: "#000000",
  };

  return (
    <SafeAreaView style={backgroundStyle}>
      <StatusBar barStyle='light-content' />
      <JivoSDKButton />
    </SafeAreaView>
  );
};
```

## Описание методов

### `startUpSession(channelID, userToken)`

Устанавливает соединение между SDK и нашими серверами, создавая новую сессию, либо возобновляя уже существующую. 

> Не вызывайте этот метод при отображённом на экране UI чата Jivo SDK.

> Всегда вызывайте метод shutDownSession() перед тем, как повторно вызвать метод startUpSession(channelID, userToken) с параметром userToken, отличным от того, что использовался в сессии ранее. 

**Параметры:**
- `channelID: string` – идентификатор вашего канала в Jivo; 
- `userToken: string` – уникальный ключ для клиента, зашедшего в чат, по которому определяется, требуется ли создать новую сессию с новым диалогом, либо восстановить уже существующую и загрузить историю начатого диалога. userToken сохраняется в Keychain, поэтому восстановление сессии возможно и после удаления-переустановки приложения, и при смене девайса (при условии включенной синхронизации данных Keychain).
#
### `setSessionCallbacks()`

Задаёт функции обратного вызова, которые срабатывают при возникновении соответствующих событий в рамках сессии.

> На данный момент метод ничего не принимает в качестве параметров. Расскажите нам, какие функции обратного вызова вы бы хотели иметь возможность передавать в этот метод?
#
### `updateSessionCustomData(customData)`

Задаёт дополнительную информацию о клиенте, которая отображается оператору.

> На данный момент реализация метода такова, что для обновления дополнительной информации о клиенте на стороне оператора вам необходимо вызвать метод `startUpSession(channelID, userToken)` после изменения `customData`.

**Параметры:**
- `customData: Object` – дополнительная информация о клиенте, которая указывается в полях объекта: 
  - `name: string` – имя клиента; 
  - `email: string` – E-mail клиента; 
  - `phone: string` – телефон клиента; 
  - `brief: string` – дополнительная информация о клиенте в произвольной форме. 
#
### `setPushToken(hexString)`

Передаёт в SDK PUSH-токен устройства в видe строки, ассоциируя его с клиентом сессии.

Когда PUSH-токен устройства попадает в SDK, он ассоциируется с конкретным клиентом и отправляется на сервер Jivo. После того, как сервер получает токен, у него появляется возможность отправлять PUSH-уведомления на устройство.

Если PUSH-токен устройства был задан до вызова метода  `startUpSession(channelID, userToken)`, то он сохраняется в SDK и будет отправлен на сервер Jivo после установления соединения. В случае, если PUSH-токен был установлен после вызова метода `startUpSession(channelID:userToken:)`, токен будет отправлен немедленно.

Для того, чтобы отписать устройство от PUSH уведомлений, вызовите метод `shutDownSession()`.

**Параметры:**
- `hexString: string` – шестнадцатеричная строка PUSH-токена девайса.
#
### `handlePushRawPayload(rawPayload, deliveryDate, callback)`

Обрабатывает данные PUSH-уведомления и возвращает в функции обратного вызова `true`, если уведомление было отправлено со стороны Jivo, либо `false`.

**Параметры:**
- `rawPayload: Object` – объект с данными из тела PUSH-уведомления;
- `deliveryDate: number` – дата и время доставки PUSH-уведомления, выраженное в Unix-времени;
- `callback: (?boolean) => ()` – функция обратного вызова, принимающая результат обработки данных PUSH-уведомления.
#
### `shutDownSession()`

Закрывает текущее соединение, производит очистку локальной базы данных и отправляет запрос на отписку устройства от PUSH-уведомлений для клиента сессии. 

> Всегда вызывайте метод `shutDownSession()` перед тем, как повторно вызвать метод `startUpSession(channelID, userToken)` с параметром `userToken`, отличным от того, что использовался в сессии ранее.
#
### `presentChattingUI()`

Отображает UI чата поверх всех других UI-элементов на экране нативными средствами UIKit, используя конфигурацию UI по-умолчанию.
#
### `presentChattingUIWithConfig(config)`

Отображает UI чата поверх всех других UI-элементов на экране нативными средствами UIKit, используя переданную конфигурацию UI.

**Параметры:**
- `config: Object` – конфигурация отображаемого UI. Вы можете настроить пользовательский интерфейс, используя следующие поля:
- `localeIdentifier: string` – код региона, язык которого будет использоваться при локализации UI чата;
- `icon: Object` (или `string`) – иконка, отображаемая в верхнем баре над окном чата до того, как оператор подключится к диалогу. Если у оператора установлен аватар, то он заменяет собой иконку сразу после загрузки.
   Вы можете либо передать объект, содержащий ссылку на изображение, либо строку с указанием режима отображения.
   
   При передаче значения параметра в виде строки допустимы следующие значения:
  - `“default”` – будет отображена стандартная иконка с логотипом Jivo;
  - `“hidden”` – иконка будет скрыта. Если у оператора установлен аватар, он заполнит собой пустое место. Иначе – никакое изображение показано не будет, а тексты заголовка и подзаголовка сместятся влево, заполняя собой пустое пространство.
  
   Если передавать параметр в виде объекта, то он обязательно должен содержать в себе поле `uri: string`, значением которого является URI для доступа к изображению. Получить такой объект можно, например, следующим образом:
   
   ```js
   const myImage = require('./someImage.png');
   const resolveAssetSource = require('react-native/Libraries/Image/resolveAssetSource');
   const resolvedImage = resolveAssetSource(myImage); // Объект иконки
   ```

- `titlePlaceholder: string` – текст заголовка по-умолчанию, отображаемого в верхнем баре над окном чата, до того момента, как SDK не получит имя оператора (оно заменит собой текст заголовка по-умолчанию);
- `titleColor: string` – цвет заголовка, отображаемого в верхнем баре над окном чата, указывается в формате `#ABCDEF`;
- `subtitleCaption: string` – текст подзаголовка, отображаемого в верхнем баре над окном чата;
- `subtitleColor: string` – цвет подзаголовка, отображаемого в верхнем баре над окном чата, указывается в формате `#ABCDEF`;
- `inputPlaceholder: string` – плейсхолдер текстового поля ввода внизу окна чата;
- `activeMessage: string` – текст активного приглашения. Активное приглашение – это сообщение, которое автоматически отображается для новых клиентов в ленте чата слева. Если не указывать значение для данного поля, то активное приглашение показано не будет.
#
### `setDebuggingLevel(level)`

С помощью этого метода вы можете задать степень того, насколько подробно будет производиться логирование в SDK. Логирование производится на нативной стороне и отображается в консоли вывода Xcode.

**Параметры:**
- `level: string` – степень логирования в SDK. Принимает следующие строковые значения:
  - `“full”` – режим полного логирования;
  - `“silent”` – логирование не ведётся.
#
### `archiveLogs(callback)`

Выполняет архивацию сохранённых записей логов и возвращает в функции обратного вызова ссылку на созданный архив и статус.

**Параметры:**
- `callback: (url: string, status: string) => ()` – функция обратного вызова, которая будет вызвана по завершению операции. В коллбэк будут переданы URL архива (если удалось создать) и статус операции.
   Параметр `status` может получить следующие строковые значения:
  - `“success”` – сохранённые записи логов были успешно заархивированы, параметр `url` содержит ссылку на созданный архив;
  - `“failedAccessing”` – не удалось получить доступ к файлу архива в папке `Caches`, параметр `url` равен `null`;
  - `“failedPreparing”` – не удалось подготовить содержимое архива, возможна ошибка кодировки, параметр `url` равен `null`.

